[{"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/index.js":"1","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/reportWebVitals.js":"2","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/App.js":"3","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/page-404.js":"4","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/switch-server.js":"5","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/index.js":"6","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/default.js":"7","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/canvas.js":"8","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/menu.js":"9","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/sidebar.js":"10","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/utils.js":"11","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/explorer/explorer.js":"12","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/schema/schema.js":"13","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/settings/settings.js":"14","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/connect/connect.js":"15","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/settings.js":"16","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/remote.js":"17","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/invana-engine.js":"18","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/websocket.js":"19","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/http.js":"20","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/gremlin.js":"21","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/invana-engine.js":"22","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/invana-engine.js":"23","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/core/utils.js":"24","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/graphson-v3.js":"25","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/utils.js":"26","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/base.js":"27","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/base.js":"28","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/utils.js":"29","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/base.js":"30","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/invana-engine.js":"31","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/gremlin.js":"32","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/base.js":"33","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/blank.js":"34","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/main-content.js":"35","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/example-data/data.js":"36","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/data/index.js":"37","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/interface/tables/index.js":"38","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/interface/utils.js":"39","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/label-detail/index.js":"40","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/vertex-detail/index.js":"41","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/core/data-store.js":"42","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/viewlets/data-management/data-sidebar.js":"43","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/viewlets/data-management/sidebar-list.js":"44"},{"size":510,"mtime":1610658465694,"results":"45","hashOfConfig":"46"},{"size":362,"mtime":1608290002870,"results":"47","hashOfConfig":"46"},{"size":1795,"mtime":1610818362991,"results":"48","hashOfConfig":"46"},{"size":696,"mtime":1608395041954,"results":"49","hashOfConfig":"46"},{"size":394,"mtime":1608394917828,"results":"50","hashOfConfig":"46"},{"size":1483,"mtime":1611050436573,"results":"51","hashOfConfig":"46"},{"size":3402,"mtime":1611048413463,"results":"52","hashOfConfig":"46"},{"size":335,"mtime":1608419132577,"results":"53","hashOfConfig":"46"},{"size":825,"mtime":1610648011874,"results":"54","hashOfConfig":"46"},{"size":268,"mtime":1610549400280,"results":"55","hashOfConfig":"46"},{"size":559,"mtime":1610658465615,"results":"56","hashOfConfig":"46"},{"size":4226,"mtime":1610565374988,"results":"57","hashOfConfig":"46"},{"size":271,"mtime":1610549400273,"results":"58","hashOfConfig":"46"},{"size":275,"mtime":1610549400272,"results":"59","hashOfConfig":"46"},{"size":9995,"mtime":1610549400279,"results":"60","hashOfConfig":"46"},{"size":1562,"mtime":1610802951379,"results":"61","hashOfConfig":"46"},{"size":7561,"mtime":1610823759957,"results":"62","hashOfConfig":"46"},{"size":1040,"mtime":1610549400241,"results":"63","hashOfConfig":"46"},{"size":3274,"mtime":1610658465709,"results":"64","hashOfConfig":"46"},{"size":795,"mtime":1610549400241,"results":"65","hashOfConfig":"46"},{"size":959,"mtime":1610549400244,"results":"66","hashOfConfig":"46"},{"size":3569,"mtime":1610549400245,"results":"67","hashOfConfig":"46"},{"size":1301,"mtime":1610549400245,"results":"68","hashOfConfig":"46"},{"size":1439,"mtime":1610803008678,"results":"69","hashOfConfig":"46"},{"size":10047,"mtime":1610549400245,"results":"70","hashOfConfig":"46"},{"size":1852,"mtime":1610658465627,"results":"71","hashOfConfig":"46"},{"size":961,"mtime":1610549400244,"results":"72","hashOfConfig":"46"},{"size":2920,"mtime":1610658465704,"results":"73","hashOfConfig":"46"},{"size":198,"mtime":1610549400245,"results":"74","hashOfConfig":"46"},{"size":753,"mtime":1610549400245,"results":"75","hashOfConfig":"46"},{"size":817,"mtime":1610658465716,"results":"76","hashOfConfig":"46"},{"size":407,"mtime":1607441280380,"results":"77","hashOfConfig":"46"},{"size":643,"mtime":1607441280379,"results":"78","hashOfConfig":"46"},{"size":353,"mtime":1610549400248,"results":"79","hashOfConfig":"46"},{"size":295,"mtime":1610549400248,"results":"80","hashOfConfig":"46"},{"size":798,"mtime":1610715682639,"results":"81","hashOfConfig":"46"},{"size":1180,"mtime":1611048488071,"results":"82","hashOfConfig":"46"},{"size":18512,"mtime":1610860417019,"results":"83","hashOfConfig":"46"},{"size":11764,"mtime":1610803071564,"results":"84","hashOfConfig":"46"},{"size":8441,"mtime":1611048464484,"results":"85","hashOfConfig":"46"},{"size":2996,"mtime":1611048443516,"results":"86","hashOfConfig":"46"},{"size":17382,"mtime":1610803084991,"results":"87","hashOfConfig":"46"},{"size":1893,"mtime":1611050154896,"results":"88","hashOfConfig":"46"},{"size":3690,"mtime":1611048397410,"results":"89","hashOfConfig":"46"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},"1urfhgo",{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"123","messages":"124","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"127","messages":"128","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"129","messages":"130","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"131","messages":"132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"137","messages":"138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"143","messages":"144","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"145","messages":"146","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"147","messages":"148","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"149","messages":"150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"157"},{"filePath":"158","messages":"159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"162","messages":"163","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"164","messages":"165","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"166","messages":"167","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"168","usedDeprecatedRules":"92"},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"171","messages":"172","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"173","messages":"174","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"175","messages":"176","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"177","usedDeprecatedRules":"92"},{"filePath":"178","messages":"179","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},{"filePath":"180","messages":"181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"92"},"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/index.js",[],["182","183"],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/reportWebVitals.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/App.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/page-404.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/switch-server.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/index.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/default.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/canvas.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/menu.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/sidebar.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/utils.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/explorer/explorer.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/schema/schema.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/settings/settings.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/connect/connect.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/settings.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/remote.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/invana-engine.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/websocket.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/http.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/gremlin.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/invana-engine.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/invana-engine.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/core/utils.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/graphson-v3.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/utils.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/base.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/base.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/query-builder/utils.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/serializers/base.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/invana-engine.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/gremlin.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/connector/responses/base.js",[],["184","185"],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/layout/blank.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/ui-components/main-content.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/example-data/data.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/data/index.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/interface/tables/index.js",["186","187"],"import React, {Fragment} from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./index.scss\";\nimport {getDataFromLocalStorage} from \"../../utils\";\nimport {renderPropertyData} from \"../utils\";\n\n\nexport default class TableInterface extends React.Component {\n\n    static defaultProps = {\n        // dataStore: null,\n        elementsData: [],\n        elementsLabel: \"Collection label\",\n        elementsType: \"vertex\",\n        elementsSchema: null,\n\n    }\n\n    static propTypes = {\n        // dataStore: PropTypes.object,\n        elementsData: PropTypes.array,\n        elementsLabel: PropTypes.string,\n        elementsType: PropTypes.string,\n        elementsSchema: PropTypes.object,\n        showLabel: PropTypes.bool\n    }\n\n    render() {\n\n        return (\n            <div className={\"p-10 tableCanvas\"}>\n                <div className={\"___responseBox \"}>\n                    {\n\n                        this.props.elementsType === \"vertex\"\n                            ?\n                            <VertexTableComponent type={\"Vertex\"}\n                                                  showLabel={this.props.showLabel}\n                                                  vertexSchema={this.props.elementsSchema}\n                                                  dataStore={this.props.dataStore}\n                                                  label={this.props.elementsLabel}\n                                                  data={this.props.elementsData}/>\n\n                            : <span/>\n\n                    }\n                    {\n                        this.props.elementsType === \"edge\"\n                            ?\n                            <EdgeTableComponent type={\"Edge\"}\n\n                                                showLabel={this.props.showLabel}\n                                                label={this.props.elementsLabel}\n                                                data={this.props.elementsData}/>\n\n                            : <span/>\n                    }\n                </div>\n            </div>\n        )\n    }\n}\n\nexport class VertexTableComponent extends React.Component {\n    static defaultProps = {\n        data: null,\n        label: null,\n        vertexSchema: {},\n        dataStore: null,\n        type: null,\n        showLabel: false\n    }\n\n    static propTypes = {\n        data: PropTypes.arrayOf(\n            PropTypes.shape({\n                properties: PropTypes.object,\n                type: PropTypes.string\n            })\n        ),\n        vertexSchema: PropTypes.object,\n        dataStore: PropTypes.object,\n        label: PropTypes.string,\n        type: PropTypes.string,\n        showLabel: PropTypes.bool\n    }\n\n    getPropertyKeys() {\n        if (this.props.data.length === 0) {\n            return []\n        } else {\n            return Object.keys(this.props.data[0].properties || {})\n        }\n    }\n\n    getElementType(elem) {\n        console.log(\"====elem\", elem)\n        return elem.type === \"g:Vertex\" ? \"V\" : \"E\";\n    }\n\n    getElementColor(elem) {\n        const elType = this.getElementType(elem);\n        if (elType === \"V\" && elem.meta) {\n            return elem.meta.shapeOptions.fillColorHex;\n        } else if (elType === \"E\" && elem.meta) {\n            return elem.meta.shapeOptions.strokeColorHex;\n        }\n    }\n\n    getInELabels() {\n        let inELabelsConfig = []\n        this.props.vertexSchema.inE.map((inELabel) => {\n            inELabelsConfig.push({\n                edgeFillColorHex: this.props.dataStore.getEdgeOptions(inELabel)\n                    ? this.props.dataStore.getEdgeOptions(inELabel).shapeOptions.strokeColorHex\n                    : \"#efefef\",\n                edgeLabel: inELabel\n            })\n        });\n        return inELabelsConfig;\n    }\n\n    getOutELabels() {\n        let outELabelsConfig = []\n        this.props.vertexSchema.outE.map((outELabel) => {\n            // console.log(\"====this.props.getEdgeOptions(outELabel)\", this.props.dataStore.getEdgeOptions(outELabel))\n            outELabelsConfig.push({\n                edgeFillColorHex: this.props.dataStore.getEdgeOptions(outELabel)\n                    ? this.props.dataStore.getEdgeOptions(outELabel).shapeOptions.strokeColorHex\n                    : \"#efefef\",\n                edgeLabel: outELabel\n            })\n        });\n        return outELabelsConfig;\n    }\n\n    getFirstElement() {\n        return this.props.data[0];\n    }\n\n    render() {\n        console.log(\"======this.props.data\", this.props.data);\n        const propertyKeys = this.getPropertyKeys();\n\n        const elColor = this.props.data.length > 0 ? this.getElementColor(this.props.data[0]) : \"\";\n\n\n        // console.log(\"VertexTableComponent here\", this.props.label)\n        // console.log(\"VertexTableComponent here  this.props.data[0]\", this.props.data[0])\n        // console.log(\"VertexTableComponent vertexSchema\", this.props.label, this.props.vertexSchema)\n        let colorOptions = {};\n        if (this.props.type === \"Vertex\") {\n            const _ = getDataFromLocalStorage(\"nodeLabels\", true) || {}\n            colorOptions = _[this.props.label] || {};\n        } else {\n            const _ = getDataFromLocalStorage(\"linkLabels\", true) || {}\n            colorOptions = _[this.props.label] || {}\n        }\n\n        const inELabels = [];// this.getInELabels();\n        const outELabels = []; // this.getOutELabels();\n\n        return (\n\n            <div className={\"VertexTableComponent\"}>\n                {/*<h3>{this.props.type} | {this.props.label}</h3>*/}\n                <table className={\"mb-10\"} style={{\"width\": \"calc(100vw - 295px);\"}}>\n                    <thead>\n                    <tr style={{\n                        \"backgroundColor\": colorOptions.bgColor,\n                    }}>\n                        {\n                            this.props.showLabel === true\n                                ? <th colSpan={2}>MetaData</th>\n                                : <th colSpan={1}>Id</th>\n                        }\n                        {propertyKeys.length\n                            ? <th colSpan={propertyKeys.length}>Properties</th>\n                            : <Fragment/>\n                        }\n                        {\n                            inELabels.length > 0\n                                ? <th colSpan={inELabels.length}>InE Data</th>\n                                : <React.Fragment/>\n                        }\n                        {\n                            outELabels.length > 0\n                                ? <th colSpan={outELabels.length}>OutE Data</th>\n                                : <React.Fragment/>\n                        }\n                    </tr>\n                    <tr style={{\n                        \"backgroundColor\": colorOptions.bgColor,\n                    }}>\n                        {\n                            this.props.showLabel === true\n                                ? <td>Label<span>({this.getElementType(this.getFirstElement())})</span></td>\n                                : <React.Fragment/>\n                        }\n\n                        <td>Id</td>\n                        {\n                            propertyKeys.map((propertyKey, index) => {\n                                return (\n                                    <td key={index}>{propertyKey}</td>\n                                )\n                            })\n                        }\n                        {\n                            inELabels.length > 0\n                                ? inELabels.map((edgeLabelConfig, index) => {\n                                    return (\n                                        <td key={index}\n                                            style={{\"color\": edgeLabelConfig.edgeFillColorHex}}>{edgeLabelConfig.edgeLabel}</td>\n                                    )\n                                })\n                                : <React.Fragment/>\n                        }\n                        {\n                            outELabels.length > 0\n                                ? outELabels.map((edgeLabelConfig, index) => {\n                                    return (\n                                        <td key={index}\n                                            style={{\"color\": edgeLabelConfig.edgeFillColorHex}}>{edgeLabelConfig.edgeLabel}</td>\n                                    )\n                                })\n                                : <React.Fragment/>\n                        }\n                    </tr>\n                    </thead>\n                    <tbody>\n                    {\n                        this.props.data.map((node) => {\n                            return (\n                                <tr key={node.id}>\n                                    {/*<td>{node.type}</td>*/}\n                                    {\n                                        this.props.showLabel === true\n                                            ? <td style={{\"color\": elColor}}>{node.label}</td>\n                                            : <React.Fragment/>\n                                    }\n\n                                    {/*<td><a  href={\"/vertex/\" + node.id}>{node.id}</a></td>*/}\n                                    <td><strong>{node.id}</strong></td>\n                                    {\n                                        propertyKeys.map((prop, index) => {\n                                            return (\n                                                <td key={index}>{renderPropertyData(prop, node.properties[prop])}</td>)\n                                        })\n                                    }\n                                    {\n                                        inELabels.map((inELabelConfig, index) => {\n                                            const vertices = node.inData[inELabelConfig.edgeLabel]\n                                                ? node.inData[inELabelConfig.edgeLabel].vertices\n                                                : [];\n                                            return (\n                                                <td key={index}>\n                                                    {\n                                                        vertices.map((vertex, vtxIndex) => {\n                                                            return (\n                                                                <button className={\"btn\"} key={vtxIndex}\n                                                                        title={vertex.label}\n                                                                        style={{\"borderColor\": vertex.fillColorHex}}>\n                                                                    {vertex.labelText}\n                                                                </button>\n                                                            )\n                                                        })\n                                                    }\n                                                </td>\n                                            )\n                                        })\n                                    }\n                                    {\n                                        outELabels.map((outELabelConfig, index) => {\n                                            const vertices = node.outData[outELabelConfig.edgeLabel]\n                                                ? node.outData[outELabelConfig.edgeLabel].vertices\n                                                : [];\n                                            return (\n                                                <td key={index}>\n                                                    {\n                                                        vertices.map((vertex, vtxIndex) => {\n                                                            return (\n                                                                <button className={\"btn\"} key={vtxIndex}\n                                                                        title={vertex.label}\n                                                                        style={{\"borderColor\": vertex.fillColorHex}}>\n                                                                    {vertex.labelText}\n                                                                </button>\n                                                            )\n                                                        })\n                                                    }\n                                                </td>\n                                            )\n                                        })\n                                    }\n                                </tr>\n                            )\n                        })\n                    }\n                    </tbody>\n                </table>\n\n\n            </div>\n        )\n    }\n\n}\n\nexport class EdgeTableComponent extends React.Component {\n    static defaultProps = {\n        data: null,\n        label: null,\n        type: null\n    }\n\n    static propTypes = {\n        data: PropTypes.arrayOf(\n            PropTypes.shape({\n                properties: PropTypes.object,\n                type: PropTypes.string\n            })\n        ),\n        label: PropTypes.string,\n        type: PropTypes.string,\n    }\n\n    getPropertyKeys() {\n        if (this.props.data.length === 0) {\n            return []\n        } else {\n            return Object.keys(this.props.data[0].properties || {})\n        }\n    }\n\n    getElementType(elem) {\n        return elem.type === \"g:Vertex\" ? \"V\" : \"E\";\n    }\n\n    getElementColor(elem) {\n        const elType = this.getElementType(elem);\n        if (elType === \"V\" && elem.meta) {\n            return elem.meta.shapeOptions.fillColorHex;\n        } else if (elType === \"E\" && elem.meta) {\n            return elem.meta.shapeOptions.strokeColorHex;\n        }\n    }\n\n    render() {\n        const propertyKeys = this.getPropertyKeys();\n\n        const elColor = this.props.data.length > 0 ? this.getElementColor(this.props.data[0]) : \"\";\n\n        // console.log(\"EdgeTableComponent here\", this.props.label)\n        // console.log(\"EdgeTableComponent here  this.props.data[0]\", this.props.data[0])\n        let colorOptions = {};\n        if (this.props.type === \"Vertex\") {\n            const _ = getDataFromLocalStorage(\"nodeLabels\", true) || {}\n            colorOptions = _[this.props.label] || {};\n        } else {\n            const _ = getDataFromLocalStorage(\"linkLabels\", true) || {}\n            colorOptions = _[this.props.label] || {}\n        }\n\n        return (\n            <div className={\"VertexTableComponent\"}>\n                {/*<h3>{this.props.type} | {this.props.label}</h3>*/}\n\n                {\n                    this.props.data.length > 0\n                        ? <table className={\" mb-10 \"} style={{\"width\": \"calc(100vw - 295px);\"}}>\n                            <thead>\n                            <tr style={{\n                                \"backgroundColor\": colorOptions.bgColor,\n                            }}>\n\n\n                                <th colSpan={2}>MetaData</th>\n                                {propertyKeys.length\n                                    ? <th colSpan={propertyKeys.length}>Properties</th>\n                                    : <Fragment/>\n                                }\n                                <th>from</th>\n                                <th>to (outV)</th>\n                            </tr>\n                            <tr style={{\n                                \"backgroundColor\": colorOptions.bgColor,\n                            }}>\n\n                                {/*style={{\"borderColor\": colorOptions.borderColor || \"inherit\"}}*/}\n                                {/*<th>Type</th>*/}\n                                <td>Label<span>({this.getElementType(this.props.data[0])})</span></td>\n                                <td>Id</td>\n                                {\n                                    propertyKeys.map((propertyKey, index) => {\n                                        return (\n                                            <td key={index}>{propertyKey}</td>\n                                        )\n                                    })\n                                }\n                                <td>from</td>\n                                <td>to (outV)</td>\n                            </tr>\n                            </thead>\n                            <tbody>\n                            {\n                                this.props.data.map((node) => {\n                                    return (\n                                        <tr key={node.id}>\n                                            {/*<td>{node.type}</td>*/}\n                                            <td style={{\"color\": elColor}}>{node.label}</td>\n                                            <td>{node.id}</td>\n                                            {\n\n                                                propertyKeys.map((prop, index) => {\n                                                    return (\n                                                        <td key={index}>{renderPropertyData(prop, node.properties[prop])}</td>)\n                                                })\n                                            }\n                                            <td>\n                                                <button className={\"btn\"} title={node.label}\n                                                        style={{\"borderColor\": node.source.meta.shapeOptions.fillColorHex}}>\n                                                    {node.source.meta.labelOptions.labelText}</button>\n                                            </td>\n                                            <td>\n                                                <button className={\"btn\"} title={node.label}\n                                                        style={{\"borderColor\": node.target.meta.shapeOptions.fillColorHex}}>\n                                                    {node.target.meta.labelOptions.labelText}</button>\n                                            </td>\n                                        </tr>\n                                    )\n                                })\n                            }\n                            </tbody>\n                        </table>\n                        : <React.Fragment/>\n                }\n\n\n            </div>\n        )\n    }\n\n}\n\n","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/interface/utils.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/label-detail/index.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/views/vertex-detail/index.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/core/data-store.js",["188","189"],"\nimport {convertMapKeysToArray} from \"./utils\";\nimport {\n    prepareLinkDataWithOptions,\n    prepareLinksDataForCurves,\n    prepareNodesDataWithOptions\n} from \"../web/interface/utils\";\n\nexport default class InMemoryDataStore {\n    /*\n    in-memory example-data storage to save the responses example-data\n\n    TODO - tons of performance issues to fix;\n     review neighbor and not neighbor calc methods to start with\n\n\n     */\n\n    focusedNodes = [];\n\n    // Data of raw  example-data from the response objects; for storage and retrieval purpose\n    #vertices = new Map()\n    #edges = new Map()\n\n    // For moving and controlling highlighting of the links\n    // TODO - move this to graphics store\n    linkGraphicsArray = [];\n    linkLabelGraphicsArray = [];\n\n    verticesStats = new Map();\n    edgesStats = new Map();\n\n    // Data of the 2D arrangement of vertices and links\n    verticesToRender = [];\n    edgesToRender = [];\n\n    verticesAlreadyRendered = [];\n    edgesAlreadyRendered = [];\n\n\n    vertexOptions = new Map() // to save vertex meta options\n    edgeOptions = new Map() // to save edge meta options.\n\n\n    edgeUniqueStringDelimiter = \"=====\"; // used to create unique links info for the schema\n    schema = new Map() // {'sourceLabel': ['sourceLabel--targetLabel--edgeLabel],\n    // 'targetLabel': ['sourceLabel--targetLabel--edgeLabel],\n    // 'otherLabel': [] // no links)\n    //{ \"vertexId\": {\"neighbourLinks\": [ \"linkid-1\", \"linkid-2\"], \"neighbourNodes\": [\"nodeid-1\" ]}\n    // neighbourVerticesAndLinksMap = new Map();\n\n    constructor() {\n        this.resetData()\n    }\n\n\n    getUniqueFocusedNodes() {\n        const focusedNodes = Object.assign([], this.focusedNodes);\n        let uniqueMap = {};\n        focusedNodes.forEach((node) => {\n            uniqueMap[node.id] = node;\n        });\n        const uniqueNodes = Object.values(uniqueMap);\n        console.log(\"=========uniqueNodes==>>\", uniqueNodes)\n        return uniqueNodes;\n    }\n\n    checkIfVertexExist(vertexId) {\n        return !!this.#vertices.get(vertexId);\n    }\n\n    checkIfEdgeExist(vertexId) {\n        return !!this.#edges.get(vertexId)\n    }\n\n    addVertexToDataSet(vertex) {\n        this.#vertices.set(vertex.id, vertex);\n    }\n\n    addEdgeToDataSet(edge) {\n        this.#edges.set(edge.id, edge);\n    }\n\n    // computeNeighbors() {\n    //\n    //\n    //     // this.neighbourVerticesAndLinksMap\n    // }\n    //\n    // getNodeByNodeLabelTextOrId(labelTextOrId) {\n    //\n    //     for (const [nodeId, nodeData] of this.#vertices.entries()) {\n    //         // console.log(\"=====key\", key);\n    //         if (labelTextOrId === nodeId) {\n    //             return nodeData;\n    //         }\n    //         if (nodeData.meta.labelOptions.labelText === labelTextOrId) {\n    //             return nodeData;\n    //         }\n    //         // example-data.push(value);\n    //     }\n    //\n    //     return\n    // }\n\n    searchNodeByNodeLabelTextOrId(labelTextOrId) {\n        console.log(\"searchNodeByNodeLabelTextOrId\", labelTextOrId, Number.isInteger(labelTextOrId))\n        let results = [];\n        const intLabelTextOrIdInt = parseInt(labelTextOrId);\n        const strLabelTextOrIdInt = labelTextOrId.toString();\n        for (const [nodeId, nodeData] of this.#vertices.entries()) {\n            // console.log(\"=====key\", key);\n            if (strLabelTextOrIdInt === nodeId || intLabelTextOrIdInt === nodeId) {\n                // covers both text and string version of the word\n                results.push(nodeData);\n            } else if (nodeData.meta.labelOptions.labelText) {\n                // const intVersionOfTextOrId = parseInt(nodeData.meta.labelOptions.labelText);\n                const strVersionOfTextOrId = nodeData.meta.labelOptions.labelText.toString().toLowerCase();\n                if (strVersionOfTextOrId.includes(strLabelTextOrIdInt)) {\n                    results.push(nodeData);\n                }\n                // .includes(labelTextOrId)\n            }\n            // example-data.push(value);\n        }\n\n        return results;\n    }\n\n    computeDataDistributionStats() {\n        this.verticesStats = new Map(); // resetting the stats\n        this.edgesStats = new Map(); // resetting the stats\n\n        convertMapKeysToArray(this.#vertices).forEach((vertex) => {\n            const existingLabelStats = this.verticesStats.get(vertex.label);\n            if (this.verticesStats.get(vertex.label)) {\n                this.verticesStats.set(vertex.label, existingLabelStats + 1)\n            } else {\n                this.verticesStats.set(vertex.label, 1)\n            }\n        })\n\n        convertMapKeysToArray(this.#edges).forEach((edge) => {\n            const existingLabelStats = this.edgesStats.get(edge.label);\n            if (this.edgesStats.get(edge.label)) {\n                this.edgesStats.set(edge.label, existingLabelStats + 1)\n            } else {\n                this.edgesStats.set(edge.label, 1)\n            }\n        })\n    }\n\n\n    addVertexToSchema(vertex) {\n\n        if (!this.schema.get(vertex.label)) {\n            this.schema.set(vertex.label, []);\n        }\n    }\n\n    checkIfEdgeExistInSchema(vertexEdges, edgeUniqueStr) {\n        // const nodeSchema = this.schema.get(vertexLabel);\n        return vertexEdges.includes(edgeUniqueStr);\n    }\n\n    generateEdgeUniqueString(edge) {\n        // sourceVLabel + delimiter + targetVLabel + delimiter + edgeLabel\n        return edge.outVLabel + this.edgeUniqueStringDelimiter + edge.inVLabel + this.edgeUniqueStringDelimiter + edge.label;\n    }\n\n    addEdgeToSchema(edge) {\n        const edgeUniqueStr = this.generateEdgeUniqueString(edge);\n        // inV label example-data\n        const inVEdges = this.schema.get(edge.inVLabel);\n        const outVEdges = this.schema.get(edge.outVLabel);\n        if (inVEdges && !this.checkIfEdgeExistInSchema(inVEdges, edgeUniqueStr)) {\n            inVEdges.push(edgeUniqueStr);\n            this.schema.set(edge.inVLabel, inVEdges);\n        }\n        if (outVEdges && !this.checkIfEdgeExistInSchema(outVEdges, edgeUniqueStr)) {\n            outVEdges.push(edgeUniqueStr);\n            this.schema.set(edge.outVLabel, outVEdges);\n        }\n    }\n\n    getVertexSchema(vertexLabel) {\n        const vertexEdges = this.schema.get(vertexLabel);\n        let inE = [];\n        let outE = [];\n\n        vertexEdges.map((vertexEdge) => {\n            const [sourceLabel, targetLabel, edgeLabel] = vertexEdge.split(this.edgeUniqueStringDelimiter);\n            if (sourceLabel === vertexLabel) {\n                if (!outE.includes(sourceLabel)) {\n                    outE.push(edgeLabel)\n                }\n            } else if (targetLabel === vertexLabel) {\n                if (!inE.includes(targetLabel)) {\n                    inE.push(edgeLabel)\n                }\n            }\n        });\n        return {inE, outE}\n    }\n\n    addToVertexOptions(vertex) {\n        if (!this.vertexOptions.get(vertex.label)) {\n            this.vertexOptions.set(vertex.label, vertex.meta);\n        }\n    }\n\n    getVertexOptions(vertexLabel) {\n        return this.vertexOptions.get(vertexLabel);\n    }\n\n    getEdgeOptions(edgeLabel) {\n        return this.edgeOptions.get(edgeLabel);\n    }\n\n    addToEdgeOptions(edge) {\n        if (!this.edgeOptions.get(edge.label)) {\n            this.edgeOptions.set(edge.label, edge.meta);\n        }\n    }\n\n    addData(newVertices, newEdges, onDataUpdated) {\n        // make sure the newly added edges example-data has respective nodes example-data.\n        let _this = this;\n        for (let vertexI in newVertices) {\n            let vertex = newVertices[vertexI];\n            let doesNodeExist = _this.checkIfVertexExist(vertex.id);\n            if (!doesNodeExist) {\n                _this.addVertexToDataSet(vertex);\n            }\n            this.addVertexToSchema(vertex);\n            this.addToVertexOptions(vertex);\n        }\n        for (let edgeI in newEdges) {\n            let edge = newEdges[edgeI];\n            let doesEdgeExist = _this.checkIfEdgeExist(edge.id);\n            if (!doesEdgeExist) {\n                this.addEdgeToDataSet(edge)\n            }\n            let checkIfInVExistInStore = _this.checkIfVertexExist(edge.inV);\n            // console.log(\"checkIfInVExistInStore\", checkIfInVExistInStore, edge.inV);\n            if (!checkIfInVExistInStore) {\n                this.addVertexToDataSet({id: edge.inV, label: edge.inVLabel, type: \"g:Vertex\", properties: {}});\n            }\n            let checkIfOutVExistInStore = _this.checkIfVertexExist(edge.outV);\n\n            if (!checkIfOutVExistInStore) {\n                this.addVertexToDataSet({id: edge.outV, label: edge.outVLabel, type: \"g:Vertex\", properties: {}});\n            }\n            this.addEdgeToSchema(edge);\n            this.addToEdgeOptions(edge);\n        }\n        // this will compute the stats of each nodes and links\n        this.computeDataDistributionStats();\n        if (onDataUpdated) {\n            onDataUpdated();\n        }\n    }\n\n    getAllData() {\n        return {vertices: this.#vertices, edges: this.#edges}\n    }\n\n    setDataToRender(verticesToRender, edgesToRender) {\n        console.log(\"=====setDataToRender triggered\", verticesToRender.length, edgesToRender.length);\n        this.verticesToRender = verticesToRender;\n        this.edgesToRender = edgesToRender;\n    }\n\n    getDataToRender() {\n        const keyValueArray = this.verticesToRender.map(entry => [entry['id'], entry]);\n        const map = new Map(keyValueArray);\n        const verticesToRender = Array.from(map.values());\n\n        const keyValueArrayEdge = this.edgesToRender.map(entry => [entry['id'], entry]);\n        const mapEdge = new Map(keyValueArrayEdge);\n        const edgesToRender = Array.from(mapEdge.values());\n        return {verticesToRender: verticesToRender, edgesToRender: edgesToRender};\n    }\n\n    checkIfNodeIsInVorOutV(link, nodeData) {\n        if (link.inV === nodeData.id) {\n            return \"inV\";\n        } else if (link.outV === nodeData.id) {\n            return \"outV\";\n        }\n    }\n\n\n    getNodeBasicInfo(nodeData) {\n        return {\n            id: nodeData.id,\n            labelText: nodeData.meta.labelOptions.labelText,\n            label: nodeData.label,\n            fillColorHex: nodeData.meta.shapeOptions.fillColorHex\n        }\n    }\n\n    groupLinksToInEAndOutEByLabel(links, nodeData) {\n        let inVGroups = {};\n        let outVGroups = {};\n        let _this = this;\n        links.forEach(function (link) {\n            // TODO - review this for performance.\n\n            const linkType = _this.checkIfNodeIsInVorOutV(link, nodeData);\n            if (linkType === \"inV\") {\n                // so this node is an inV, so lets gather the info or outV for this, which is source (from d3)\n                if (link.label in inVGroups) {\n                    inVGroups[link.label].vertices.push(_this.getNodeBasicInfo(link.source))\n                } else {\n                    inVGroups[link.label] = {\n                        // edgeLabel: \"InE Label 1\",\n                        edgeFillColorHex: link.meta.shapeOptions.strokeColorHex,\n                        vertices: [_this.getNodeBasicInfo(link.source)]\n                    }\n\n                }\n            } else if (linkType === \"outV\") {\n                if (link.label in outVGroups) {\n                    outVGroups[link.label].vertices.push(_this.getNodeBasicInfo(link.target))\n                } else {\n                    outVGroups[link.label] = {\n                        // edgeLabel: \"InE Label 1\",\n                        edgeFillColorHex: link.meta.shapeOptions.strokeColorHex,\n                        vertices: [_this.getNodeBasicInfo(link.target)]\n                    }\n                }\n            }\n\n        });\n        return {inVGroups, outVGroups};\n    }\n\n    determineAllDataToRender() {\n        console.log(\"=====getDataToRender triggered\");\n        const verticesData = this.getAllRawVerticesList();\n        const edgesData = this.getAllRawEdgesList();\n        const _this = this;\n\n\n        verticesData.map((vertex) => {\n            // TODO - fix performance ASAP.\n            const neighborData = this.getNeighborNodesAndLinks([vertex])\n\n            // const links = neighborData.links;\n            const {inVGroups, outVGroups} = _this.groupLinksToInEAndOutEByLabel(neighborData.links, vertex)\n\n            // group links by label\n            vertex.inData = inVGroups;\n            vertex.outData = outVGroups;\n        });\n\n        // edgesData.map((edge) => {\n        //\n        // });\n\n        const {newVerticesToRender, newEdgesToRender} = {\n            newVerticesToRender: verticesData,\n            newEdgesToRender: edgesData\n        }\n\n\n        console.log(\"======newVerticesToRender, newEdgesToRender\", newVerticesToRender, newEdgesToRender)\n\n        return {\n            verticesToRender: newVerticesToRender,\n            edgesToRender: newEdgesToRender\n        }\n    }\n\n    getVerticesCount() {\n        return this.#vertices.size;\n    }\n\n    checkIfShouldBeConvertedToGraphics() {\n\n    }\n\n    resetData() {\n        this.#vertices = new Map()\n        this.#edges = new Map()\n        this.linkGraphicsArray = [];\n        this.linkLabelGraphicsArray = [];\n    }\n\n    prepareNodes(vertices) {\n        const nodeOptions = Object.assign({}, JSON.parse(localStorage.getItem('nodeLabels')));\n        // const cleanedVertices = removeVertexMeta(convertMapKeysToArray(this.#vertices));\n        return prepareNodesDataWithOptions(vertices, nodeOptions);\n\n    }\n\n    getAllRawVerticesList() {\n        return this.prepareNodes(convertMapKeysToArray(this.#vertices))\n    }\n\n    getAllRawEdgesList() {\n        const nodeOptions = Object.assign({}, JSON.parse(localStorage.getItem('nodeLabels')));\n        return prepareLinkDataWithOptions(prepareLinksDataForCurves(convertMapKeysToArray(this.#edges)), nodeOptions);\n    }\n\n    getAlreadyRenderedData() {\n        return {\n            verticesAlreadyRendered: this.verticesAlreadyRendered,\n            edgesAlreadyRendered: this.edgesAlreadyRendered\n        }\n    }\n\n    setAlreadyRenderedData(verticesAlreadyRendered, edgesAlreadyRendered) {\n        this.verticesAlreadyRendered = verticesAlreadyRendered;\n        this.edgesAlreadyRendered = edgesAlreadyRendered;\n    }\n\n    getNeighborNodesAndLinksOfNode(nodeId) {\n        let neighborNodes = [];\n        let neighborLinks = [];\n        // get the links attached to nodeId\n        this.getAllRawEdgesList().forEach((link) => {\n            if (link.target.id === nodeId) {\n                neighborLinks.push(link);\n                neighborNodes.push(link.source);\n            } else if (link.source.id === nodeId) {\n                neighborLinks.push(link);\n                neighborNodes.push(link.target);\n            }\n        })\n\n\n        return {\n            nodes: neighborNodes,\n            links: neighborLinks\n        }\n    }\n\n\n    getNeighborNodesAndLinks(nodes) {\n        let neighborNodes = [];\n        let neighborLinks = [];\n        // get the links attached to nodeId\n        this.getAllRawEdgesList().forEach((link) => {\n            nodes.forEach((nodeData) => {\n                if (link.target.id === nodeData.id) {\n                    neighborLinks.push(link);\n                    neighborNodes.push(link.source);\n                } else if (link.source.id === nodeData.id) {\n                    neighborLinks.push(link);\n                    neighborNodes.push(link.target);\n                }\n            })\n        })\n\n\n        return {\n            nodes: neighborNodes,\n            links: neighborLinks\n        }\n    }\n\n    getNotNeighborLinks(selectedNodes) {\n        let notNeighborLinks = [];\n        let notNeighborNodes = [];\n        const {nodes, links} = this.getNeighborNodesAndLinks(selectedNodes);\n\n        nodes.push(...selectedNodes);\n        this.getAllRawVerticesList().forEach((node) => {\n            if (!nodes.includes(node)) {\n                notNeighborNodes.push(node);\n            }\n        })\n        this.getAllRawEdgesList().forEach((link) => {\n            if (!links.includes(link)) {\n                notNeighborLinks.push(link);\n            }\n        })\n        console.log(\"=====notNeighborNodes\", notNeighborNodes, notNeighborLinks)\n        return {notNeighborLinks, notNeighborNodes};\n    }\n\n\n    removeAllNodes2Focus() {\n        this.focusedNodes = [];\n    }\n\n    checkIfVertexExistInFocused(nodeData) {\n        this.focusedNodes.forEach((node) => {\n            console.log(\"======checkIfVertexExistInFocused node, nodeData\", node.id, nodeData.id);\n            if (nodeData.id === node.id) {\n                return true;\n            }\n        })\n        return false;\n    }\n\n    addNode2Focus(nodeData) {\n        if (this.checkIfVertexExistInFocused(nodeData) === false) {\n            this.focusedNodes.push(nodeData);\n        }\n    }\n\n    removeNodeFromFocus(nodeId) {\n        let focusedNodes = this.getUniqueFocusedNodes();\n        let indexId = null\n\n        focusedNodes.forEach((focusedNode, index) => {\n            if (focusedNode.id === nodeId) {\n                indexId = index\n                return index;\n            }\n        });\n        focusedNodes.splice(indexId, 1);\n\n        this.focusedNodes = focusedNodes;\n    }\n\n    getEdgesCount() {\n        return this.#edges.size;\n    }\n\n    getEdge(edgeId) {\n        return this.#edges.get(edgeId);\n    }\n\n    getVertex(nodeId) {\n        return this.#vertices.get(nodeId);\n    }\n}\n","/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/viewlets/data-management/data-sidebar.js",[],"/Users/rrmerugu/Projects/invanalabs/graph-explorer-redesign/src/web/viewlets/data-management/sidebar-list.js",[],{"ruleId":"190","replacedBy":"191"},{"ruleId":"192","replacedBy":"193"},{"ruleId":"190","replacedBy":"194"},{"ruleId":"192","replacedBy":"195"},{"ruleId":"196","severity":1,"message":"197","line":112,"column":52,"nodeType":"198","messageId":"199","endLine":112,"endColumn":54},{"ruleId":"196","severity":1,"message":"197","line":125,"column":54,"nodeType":"198","messageId":"199","endLine":125,"endColumn":56},{"ruleId":"196","severity":1,"message":"197","line":191,"column":38,"nodeType":"198","messageId":"199","endLine":191,"endColumn":40},{"ruleId":"196","severity":1,"message":"197","line":346,"column":35,"nodeType":"198","messageId":"199","endLine":346,"endColumn":37},"no-native-reassign",["200"],"no-negated-in-lhs",["201"],["200"],["201"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation"]